<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Playoffs</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <link href="https://fonts.googleapis.com/css2?family=Bebas+Neue&display=swap" rel="stylesheet">
    <link rel="icon" href="/favicon.ico">
    <link rel="icon" type="image/png" href="/moscow-m1x-draft/favicon-96x96.png" sizes="96x96" />
    <link rel="icon" type="image/svg+xml" href="/moscow-m1x-draft/favicon.svg" />
    <link rel="shortcut icon" href="/moscow-m1x-draft/favicon.ico" />
    <link rel="apple-touch-icon" sizes="180x180" href="/moscow-m1x-draft/apple-touch-icon.png" />
    <meta name="apple-mobile-web-app-title" content="Moscow-m1x-draft" />
    <link rel="manifest" href="/moscow-m1x-draft/site.webmanifest" />
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <nav class="navbar">
        <div class="logo-container">
            <img src="logo.png" alt="Moscow M1X Logo">
        </div>
        <ul class="nav-links">
            <li><a href="index.html">HOME</a></li>
            <li><a href="draft.html">DRAFT</a></li>
            <li><a href="group-stage.html">GROUP STAGE</a></li>
            <li><a href="bracket.html" class="active">PLAYOFF</a></li>
            <li><a href="results.html">RESULTS</a></li>
        </ul>
        <div class="auth-link" id="authHeaderLink">SIGN IN</div>
    </nav>
    <div class="main-content">
        <div class="header-section">
            <h1 class="bracket-header">PLAYOFFS</h1>
            <div id="formatSelectorContainer">
                <select id="bracketFormatSelect">
                    <option value="moscow-mix">Moscow Mix Format</option>
                    <option value="single-elim">Single Elimination (8 teams)</option>
                    <option value="double-elim">Double Elimination (8 teams)</option>
                </select>
            </div>
        </div>
        <div id="bracketContent">
            <div class="loading">Loading playoff bracket...</div>
        </div>
        <div class="footer-credit"></div>
    </div>
    <div class="archive-btn" id="archiveBtn" title="Архивировать результаты турнира">✔️</div>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>
    <script>
        const firebaseConfig = {
            apiKey: "AIzaSyBWnLO_5YgaNFiy-wvynVEKcMnS8V55FXY",
            authDomain: "moscow-m1x-draft-f9da4.firebaseapp.com",
            databaseURL: "https://moscow-m1x-draft-f9da4-default-rtdb.europe-west1.firebasedatabase.app",
            projectId: "moscow-m1x-draft-f9da4",
            storageBucket: "moscow-m1x-draft-f9da4.firebasestorage.app",
            messagingSenderId: "391636730262",
            appId: "1:391636730262:web:2441abb086b5336b451db7"
        };
        firebase.initializeApp(firebaseConfig);
        const database = firebase.database();
        const auth = firebase.auth();
        const groupStageRef = database.ref('moscowM1X/groupStage');
        const playoffRef = database.ref('moscowM1X/playoffBracket');
        const configRef = database.ref('moscowM1X/config');
        const draftRef = database.ref('moscowM1X/draft');
        const tournamentsRef = database.ref('moscowM1X/tournaments');
        let CAPTAINS = [];
        let TEAM_NAMES = {};
        let isAuthenticated = false;
        let isAdmin = false;
        let standings = null;
        const bracketContent = document.getElementById('bracketContent');
        let playoffDataGlobal = null;
        let CURRENT_FORMAT = 'moscow-mix';
        const BRACKET_TEMPLATES = {
            'moscow-mix': [
                { id: 'M1', round: 'Upper R1', teams: ['A1', 'B2'], nextWin: 'M8', nextLose: 'M5' },
                { id: 'M2', round: 'Upper R1', teams: ['B1', 'A2'], nextWin: 'M8', nextLose: 'M6' },
                { id: 'M8', round: 'Upper SF', teams: ['M1', 'M2'], nextWin: 'M10', nextLose: 'M9' },
                { id: 'M3', round: 'Lower R1', teams: ['B4', 'A3'], nextWin: 'M5', nextLose: null },
                { id: 'M4', round: 'Lower R1', teams: ['A4', 'B3'], nextWin: 'M6', nextLose: null },
                { id: 'M5', round: 'Lower R2', teams: ['M3', 'M2_L'], nextWin: 'M7', nextLose: null },
                { id: 'M6', round: 'Lower R2', teams: ['M4', 'M1_L'], nextWin: 'M7', nextLose: null },
                { id: 'M7', round: 'Lower R3', teams: ['M5', 'M6'], nextWin: 'M9', nextLose: null },
                { id: 'M9', round: 'Lower R4', teams: ['M7', 'M8_L'], nextWin: 'M10', nextLose: null },
                { id: 'M10', round: 'Grand Final', teams: ['M8', 'M9'], isFinal: true },
                { id: 'M11', round: 'Grand Final (if needed)', teams: ['M8', 'M9'], isFinal: true, isSecond: true }
            ],
            'single-elim': [
                { id: 'QF1', round: 'Quarterfinal', teams: ['A1', 'B4'], nextWin: 'SF1' },
                { id: 'QF2', round: 'Quarterfinal', teams: ['B2', 'A3'], nextWin: 'SF1' },
                { id: 'QF3', round: 'Quarterfinal', teams: ['B1', 'A4'], nextWin: 'SF2' },
                { id: 'QF4', round: 'Quarterfinal', teams: ['A2', 'B3'], nextWin: 'SF2' },
                { id: 'SF1', round: 'Semifinal', teams: ['QF1', 'QF2'], nextWin: 'FINAL' },
                { id: 'SF2', round: 'Semifinal', teams: ['QF3', 'QF4'], nextWin: 'FINAL' },
                { id: 'FINAL', round: 'Final', teams: ['SF1', 'SF2'], isFinal: true }
            ],
            'double-elim': [
                { id: 'UB1', round: 'Upper QF', teams: ['A1', 'B4'], nextWin: 'UB3', nextLose: 'LB1' },
                { id: 'UB2', round: 'Upper QF', teams: ['B2', 'A3'], nextWin: 'UB3', nextLose: 'LB2' },
                { id: 'UB3', round: 'Upper SF', teams: ['UB1', 'UB2'], nextWin: 'GF', nextLose: 'LB5' },
                { id: 'UB4', round: 'Upper QF', teams: ['B1', 'A4'], nextWin: 'UB6', nextLose: 'LB3' },
                { id: 'UB5', round: 'Upper QF', teams: ['A2', 'B3'], nextWin: 'UB6', nextLose: 'LB4' },
                { id: 'UB6', round: 'Upper SF', teams: ['UB4', 'UB5'], nextWin: 'GF', nextLose: 'LB5' },
                { id: 'LB1', round: 'Lower R1', teams: ['UB1_L', 'UB2_L'], nextWin: 'LB3', nextLose: null },
                { id: 'LB2', round: 'Lower R1', teams: ['UB4_L', 'UB5_L'], nextWin: 'LB4', nextLose: null },
                { id: 'LB3', round: 'Lower R2', teams: ['LB1', 'UB4_L'], nextWin: 'LB5', nextLose: null },
                { id: 'LB4', round: 'Lower R2', teams: ['LB2', 'UB5_L'], nextWin: 'LB5', nextLose: null },
                { id: 'LB5', round: 'Lower Final', teams: ['LB3', 'LB4'], nextWin: 'GF', nextLose: null },
                { id: 'GF', round: 'Grand Final', teams: ['UB3', 'LB5'], isFinal: true },
                { id: 'GF2', round: 'Grand Final (if needed)', teams: ['UB3', 'LB5'], isFinal: true, isSecond: true }
            ]
        };

        function normalizeTeamName(name) {
            return (name || '').toLowerCase().trim();
        }

        async function initializePlayoffBracket(format) {
            const template = BRACKET_TEMPLATES[format];
            if (!template) return;
            const newBracket = {
                isPlayoffActive: true,
                format: format,
                matches: {}
            };
            template.forEach(matchDef => {
                newBracket.matches[matchDef.id] = {
                    team1: matchDef.teams[0],
                    team2: matchDef.teams[1],
                    map: null,
                    score1: null,
                    score2: null,
                    completed: false,
                    winner: null,
                    loser: null,
                    sourceBracket: getBracketSource(matchDef.id, format)
                };
            });
            await playoffRef.set(newBracket);
        }

        function getBracketSource(matchId, format) {
            if (format === 'moscow-mix') {
                if (['M1', 'M2', 'M8'].includes(matchId)) return 'upper';
                if (['M3', 'M4', 'M5', 'M6', 'M7', 'M9'].includes(matchId)) return 'lower';
            } else if (format === 'single-elim') {
                return 'single';
            } else if (format === 'double-elim') {
                if (matchId.startsWith('UB')) return 'upper';
                if (matchId.startsWith('LB') || matchId === 'GF' || matchId === 'GF2') return 'lower';
            }
            return 'unknown';
        }

        function resolveTeamRecursive(id, matches, pos) {
            if (!id || id === '—') return '—';
            if (TEAM_NAMES[id]) return TEAM_NAMES[id];
            if (CAPTAINS.includes(id)) return TEAM_NAMES[id] || id;
            if (id.length === 2 && ['A','B'].includes(id[0]) && !isNaN(id[1])) {
                const captain = pos[id];
                return TEAM_NAMES[captain] || captain || '—';
            }
            if (id.endsWith('_L')) {
                const matchId = id.slice(0, -2);
                const match = matches[matchId];
                if (match && match.completed && match.loser) {
                    return resolveTeamRecursive(match.loser, matches, pos);
                }
                return '—';
            }
            if (id.startsWith('M') || id.startsWith('UB') || id.startsWith('LB') || id.startsWith('QF') || id.startsWith('SF') || id.startsWith('GF')) {
                const match = matches[id];
                if (match && match.completed) {
                    return resolveTeamRecursive(match.winner || match.loser || '—', matches, pos);
                }
            }
            return id;
        }

        function isSecondFinalNeeded(playoffData, format, pos) {
            if (format === 'moscow-mix') {
                const gf = playoffData.matches['M10'];
                if (!gf?.completed) return true;
                const upperWinner = resolveTeamRecursive('M8', playoffData.matches, pos);
                const actualWinner = resolveTeamRecursive(gf.winner, playoffData.matches, pos);
                return actualWinner !== upperWinner;
            } else if (format === 'double-elim') {
                const gf = playoffData.matches['GF'];
                if (!gf?.completed) return true;
                const upperWinner = resolveTeamRecursive('UB3', playoffData.matches, pos);
                const actualWinner = resolveTeamRecursive(gf.winner, playoffData.matches, pos);
                return actualWinner !== upperWinner;
            }
            return false;
        }

        function findFirstIncompleteMatch(playoffData, format) {
            const template = BRACKET_TEMPLATES[format] || BRACKET_TEMPLATES['moscow-mix'];
            for (const m of template) {
                const match = playoffData.matches[m.id];
                if (!match || !match.completed) return m.id;
            }
            return null;
        }

        function renderBracket(playoffData, standings) {
            playoffDataGlobal = playoffData;
            updateArchiveButtonVisibility();
            if (!standings) {
                bracketContent.innerHTML = '<div class="firebase-error">Group stage not completed yet.</div>';
                return;
            }
            const format = playoffData.format || 'moscow-mix';
            CURRENT_FORMAT = format;
            const formatSelect = document.getElementById('bracketFormatSelect');
            if (formatSelect) {
                formatSelect.value = format;
            }
            const pos = {
                'A1': getTeamName(standings.A[0]),
                'A2': getTeamName(standings.A[1]),
                'A3': getTeamName(standings.A[2]),
                'A4': getTeamName(standings.A[3]),
                'B1': getTeamName(standings.B[0]),
                'B2': getTeamName(standings.B[1]),
                'B3': getTeamName(standings.B[2]),
                'B4': getTeamName(standings.B[3])
            };

            let champion = '—';
            const matches = playoffData.matches || {};
            if (format === 'moscow-mix') {
                if (matches['M11']?.completed) {
                    champion = resolveTeamRecursive(matches['M11'].winner, matches, pos);
                } else if (matches['M10']?.completed) {
                    const upperWinner = resolveTeamRecursive('M8', matches, pos);
                    const gfWinner = resolveTeamRecursive(matches['M10'].winner, matches, pos);
                    if (gfWinner === upperWinner) {
                        champion = gfWinner;
                    }
                }
            } else if (format === 'double-elim') {
                if (matches['GF2']?.completed) {
                    champion = resolveTeamRecursive(matches['GF2'].winner, matches, pos);
                } else if (matches['GF']?.completed) {
                    const upperWinner = resolveTeamRecursive('UB3', matches, pos);
                    const gfWinner = resolveTeamRecursive(matches['GF'].winner, matches, pos);
                    if (gfWinner === upperWinner) {
                        champion = gfWinner;
                    }
                }
            } else if (format === 'single-elim') {
                if (matches['FINAL']?.completed) {
                    champion = resolveTeamRecursive(matches['FINAL'].winner, matches, pos);
                }
            }

            const container = document.createElement('div');
            container.className = 'bracket-container';
            const firstIncomplete = findFirstIncompleteMatch(playoffData, format);

            if (format === 'single-elim') {
                const cols = [
                    { matches: ['QF1', 'QF2', 'QF3', 'QF4'] },
                    { matches: ['SF1', 'SF2'] },
                    { matches: ['FINAL'] }
                ];
                const section = document.createElement('div');
                section.className = 'bracket-section';
                const colsWrapper = document.createElement('div');
                colsWrapper.className = 'bracket-cols';
                cols.forEach(col => {
                    const colEl = createColumn(col.matches, playoffData, pos, 'single', firstIncomplete, format, isSecondFinalNeeded(playoffData, format, pos));
                    colsWrapper.appendChild(colEl);
                });
                section.appendChild(colsWrapper);
                container.appendChild(section);
            } else if (format === 'double-elim') {
                const upperSection = document.createElement('div');
                upperSection.className = 'bracket-section';
                const upperCols = [
                    { matches: ['UB1', 'UB2', 'UB4', 'UB5'] },
                    { matches: ['UB3', 'UB6'] },
                    { matches: ['GF', 'GF2'] }
                ];
                const upperWrapper = document.createElement('div');
                upperWrapper.className = 'bracket-cols';
                upperCols.forEach(col => {
                    const colEl = createColumn(col.matches, playoffData, pos, 'upper', firstIncomplete, format, isSecondFinalNeeded(playoffData, format, pos));
                    upperWrapper.appendChild(colEl);
                });
                upperSection.appendChild(upperWrapper);
                container.appendChild(upperSection);

                const lowerSection = document.createElement('div');
                lowerSection.className = 'bracket-section';
                const lowerCols = [
                    { matches: ['LB1', 'LB2'] },
                    { matches: ['LB3', 'LB4'] },
                    { matches: ['LB5'] }
                ];
                const lowerWrapper = document.createElement('div');
                lowerWrapper.className = 'bracket-cols';
                lowerCols.forEach(col => {
                    const colEl = createColumn(col.matches, playoffData, pos, 'lower', firstIncomplete, format, isSecondFinalNeeded(playoffData, format, pos));
                    lowerWrapper.appendChild(colEl);
                });
                lowerSection.appendChild(lowerWrapper);
                container.appendChild(lowerSection);
            } else {
                const upperSection = document.createElement('div');
                upperSection.className = 'bracket-section';
                const upperCols = [
                    { matches: ['M1', 'M2'] },
                    { matches: ['M8'] },
                    { matches: ['M10', 'M11'] }
                ];
                const upperColsWrapper = document.createElement('div');
                upperColsWrapper.className = 'bracket-cols';
                upperCols.forEach(col => {
                    const colEl = createColumn(col.matches, playoffData, pos, 'upper', firstIncomplete, format, isSecondFinalNeeded(playoffData, format, pos));
                    upperColsWrapper.appendChild(colEl);
                });
                upperSection.appendChild(upperColsWrapper);
                container.appendChild(upperSection);

                const lowerSection = document.createElement('div');
                lowerSection.className = 'bracket-section';
                const lowerCols = [
                    { matches: ['M3', 'M4'] },
                    { matches: ['M5', 'M6'] },
                    { matches: ['M7'] },
                    { matches: ['M9'] }
                ];
                const lowerColsWrapper = document.createElement('div');
                lowerColsWrapper.className = 'bracket-cols';
                lowerCols.forEach(col => {
                    const colEl = createColumn(col.matches, playoffData, pos, 'lower', firstIncomplete, format, isSecondFinalNeeded(playoffData, format, pos));
                    lowerColsWrapper.appendChild(colEl);
                });
                lowerSection.appendChild(lowerColsWrapper);
                container.appendChild(lowerSection);
            }

            const championBox = document.createElement('div');
            championBox.className = 'champion-box';
            championBox.innerHTML = `<h2>🏆 1ST PLACE</h2><p>${champion}</p>`;
            container.appendChild(championBox);

            bracketContent.innerHTML = '';
            bracketContent.appendChild(container);
        }

        function createColumn(matchIds, playoffData, pos, bracketType, firstIncomplete, format, secondFinalNeeded) {
            const col = document.createElement('div');
            col.className = 'bracket-col';
            matchIds.forEach(id => {
                const matchDef = BRACKET_TEMPLATES[format]?.find(m => m.id === id) ||
                                 BRACKET_TEMPLATES['moscow-mix'].find(m => m.id === id);
                if (!matchDef) return;

                const match = playoffData.matches[id] || {
                    team1: matchDef.teams[0],
                    team2: matchDef.teams[1],
                    map: null,
                    score1: null,
                    score2: null,
                    completed: false,
                    winner: null,
                    loser: null,
                    sourceBracket: bracketType
                };

                const t1 = resolveTeamRecursive(match.team1, playoffData.matches, pos);
                const t2 = resolveTeamRecursive(match.team2, playoffData.matches, pos);

                const box = document.createElement('div');
                box.className = 'match-box';
                if (match.completed) box.classList.add('completed');
                if (matchDef.isFinal) box.classList.add('final-match');
                if (id === firstIncomplete) box.classList.add('current-round');

                if ((id === 'M11' && format === 'moscow-mix') || (id === 'GF2' && format === 'double-elim')) {
                    if (!secondFinalNeeded) {
                        box.classList.add('disabled-match');
                    }
                }

                const title = document.createElement('div');
                title.className = 'match-title';
                title.textContent = matchDef.round;

                const teamsDiv = document.createElement('div');
                teamsDiv.className = 'match-teams';

                const createTeamRow = (teamKey, scoreKey) => {
                    const container = document.createElement('div');
                    container.className = 'bracket-team-row';
                    if (match.completed && match.winner === match[teamKey]) {
                        container.classList.add('winner');
                    } else if (match.completed) {
                        container.classList.add('loser');
                    }
                    const nameSpan = document.createElement('span');
                    nameSpan.className = 'bracket-team-name';
                    nameSpan.textContent = resolveTeamRecursive(match[teamKey], playoffData.matches, pos) || '—';
                    const scoreSpan = document.createElement('span');
                    scoreSpan.className = 'bracket-team-score';
                    scoreSpan.textContent = match[scoreKey] !== null ? match[scoreKey] : '—';
                    container.appendChild(nameSpan);
                    container.appendChild(scoreSpan);
                    return container;
                };

                teamsDiv.appendChild(createTeamRow('team1', 'score1'));
                teamsDiv.appendChild(createTeamRow('team2', 'score2'));

                if (matchDef.nextWin) {
                    const arrow = document.createElement('div');
                    arrow.className = 'match-arrow';
                    arrow.innerHTML = '→';
                    if (match.completed) {
                        arrow.style.animation = 'pulseArrow 1.2s infinite';
                    }
                    box.appendChild(arrow);
                }

                box.appendChild(title);
                box.appendChild(teamsDiv);
                box.dataset.matchId = id;

                if (!box.classList.contains('disabled-match')) {
                    box.addEventListener('click', () => openMatchModal(id, playoffData, pos));
                }

                col.appendChild(box);
            });
            return col;
        }

        function openMatchModal(matchId, playoffData, pos) {
            const match = playoffData.matches[matchId];
            const t1 = resolveTeamRecursive(match.team1, playoffData.matches, pos);
            const t2 = resolveTeamRecursive(match.team2, playoffData.matches, pos);
            const modal = document.createElement('div');
            modal.style.position = 'fixed';
            modal.style.top = '0';
            modal.style.left = '0';
            modal.style.width = '100%';
            modal.style.height = '100%';
            modal.style.background = 'rgba(0,0,0,0.8)';
            modal.style.display = 'flex';
            modal.style.alignItems = 'center';
            modal.style.justifyContent = 'center';
            modal.style.zIndex = '2000';
            modal.style.padding = '20px';
            modal.style.opacity = '0';
            modal.style.transition = 'opacity 0.3s ease';
            setTimeout(() => { modal.style.opacity = '1'; }, 10);
            const content = document.createElement('div');
            content.style.background = 'rgba(20, 20, 40, 0.9)';
            content.style.border = '1px solid rgba(255, 204, 0, 0.4)';
            content.style.borderRadius = '12px';
            content.style.padding = '20px';
            content.style.maxWidth = 'min(400px, 90vw)';
            content.style.width = '100%';
            content.style.color = '#e0e0e0';
            content.style.transform = 'scale(0.95)';
            content.style.transition = 'transform 0.3s ease';
            setTimeout(() => { content.style.transform = 'scale(1)'; }, 10);
            const title = document.createElement('h3');
            title.style.color = '#ffcc00';
            title.style.marginBottom = '15px';
            title.textContent = `Матч ${matchId}`;
            const form = document.createElement('div');
            form.style.display = 'flex';
            form.style.flexDirection = 'column';
            form.style.gap = '10px';
            const team1Row = document.createElement('div');
            team1Row.style.display = 'flex';
            team1Row.style.alignItems = 'center';
            team1Row.style.gap = '10px';
            team1Row.innerHTML = `<span style="flex:1; overflow:hidden; text-overflow:ellipsis;">${t1}</span>`;
            const score1Span = document.createElement('span');
            score1Span.style.fontWeight = 'bold';
            score1Span.style.minWidth = '40px';
            score1Span.style.textAlign = 'center';
            score1Span.style.fontSize = '1.1em';
            score1Span.textContent = match.score1 !== null ? match.score1 : '—';
            team1Row.appendChild(score1Span);
            const team2Row = document.createElement('div');
            team2Row.style.display = 'flex';
            team2Row.style.alignItems = 'center';
            team2Row.style.gap = '10px';
            team2Row.innerHTML = `<span style="flex:1; overflow:hidden; text-overflow:ellipsis;">${t2}</span>`;
            const score2Span = document.createElement('span');
            score2Span.style.fontWeight = 'bold';
            score2Span.style.minWidth = '40px';
            score2Span.style.textAlign = 'center';
            score2Span.style.fontSize = '1.1em';
            score2Span.textContent = match.score2 !== null ? match.score2 : '—';
            team2Row.appendChild(score2Span);
            const mapLabel = document.createElement('div');
            mapLabel.style.fontSize = '0.9em';
            mapLabel.style.color = '#aaa';
            mapLabel.innerHTML = `<strong>Карта:</strong> ${match.map || '—'}`;
            const btnContainer = document.createElement('div');
            btnContainer.style.display = 'flex';
            btnContainer.style.gap = '10px';
            btnContainer.style.marginTop = '15px';
            const closeBtn = document.createElement('button');
            closeBtn.style.background = 'rgba(255, 204, 0, 0.1)';
            closeBtn.style.border = '1px solid rgba(255, 204, 0, 0.4)';
            closeBtn.style.borderRadius = '6px';
            closeBtn.style.color = '#ffcc00';
            closeBtn.style.padding = '8px 16px';
            closeBtn.style.cursor = 'pointer';
            closeBtn.style.flex = '1';
            closeBtn.style.transition = 'background 0.2s';
            closeBtn.textContent = 'Закрыть';
            closeBtn.onmouseenter = () => { closeBtn.style.background = 'rgba(255, 204, 0, 0.2)'; };
            closeBtn.onmouseleave = () => { closeBtn.style.background = 'rgba(255, 204, 0, 0.1)'; };
            closeBtn.onclick = () => {
                content.style.transform = 'scale(0.95)';
                modal.style.opacity = '0';
                setTimeout(() => { modal.remove(); }, 300);
            };
            if (isAdmin && isAuthenticated) {
                const editBtn = document.createElement('button');
                editBtn.style.background = 'rgba(255, 204, 0, 0.2)';
                editBtn.style.border = '1px solid rgba(255, 204, 0, 0.4)';
                editBtn.style.borderRadius = '6px';
                editBtn.style.color = '#ffcc00';
                editBtn.style.padding = '8px 16px';
                editBtn.style.cursor = 'pointer';
                editBtn.style.flex = '1';
                editBtn.style.transition = 'background 0.2s';
                editBtn.textContent = 'Редактировать';
                editBtn.onmouseenter = () => { editBtn.style.background = 'rgba(255, 204, 0, 0.3)'; };
                editBtn.onmouseleave = () => { editBtn.style.background = 'rgba(255, 204, 0, 0.2)'; };
                editBtn.onclick = () => {
                    content.style.transform = 'scale(0.95)';
                    modal.style.opacity = '0';
                    setTimeout(() => {
                        modal.remove();
                        openEditModal(matchId, playoffData, pos);
                    }, 300);
                };
                btnContainer.appendChild(editBtn);
            }
            btnContainer.appendChild(closeBtn);
            form.appendChild(team1Row);
            form.appendChild(team2Row);
            form.appendChild(mapLabel);
            form.appendChild(btnContainer);
            content.appendChild(title);
            content.appendChild(form);
            modal.appendChild(content);
            document.body.appendChild(modal);
        }

        function openEditModal(matchId, playoffData, pos) {
            const match = playoffData.matches[matchId];
            const t1 = resolveTeamRecursive(match.team1, playoffData.matches, pos);
            const t2 = resolveTeamRecursive(match.team2, playoffData.matches, pos);
            const modal = document.createElement('div');
            modal.style.position = 'fixed';
            modal.style.top = '0';
            modal.style.left = '0';
            modal.style.width = '100%';
            modal.style.height = '100%';
            modal.style.background = 'rgba(0,0,0,0.8)';
            modal.style.display = 'flex';
            modal.style.alignItems = 'center';
            modal.style.justifyContent = 'center';
            modal.style.zIndex = '2000';
            modal.style.padding = '20px';
            modal.style.opacity = '0';
            modal.style.transition = 'opacity 0.3s ease';
            setTimeout(() => { modal.style.opacity = '1'; }, 10);
            const content = document.createElement('div');
            content.style.background = 'rgba(20, 20, 40, 0.9)';
            content.style.border = '1px solid rgba(255, 204, 0, 0.4)';
            content.style.borderRadius = '12px';
            content.style.padding = '20px';
            content.style.maxWidth = 'min(400px, 90vw)';
            content.style.width = '100%';
            content.style.color = '#e0e0e0';
            content.style.transform = 'scale(0.95)';
            content.style.transition = 'transform 0.3s ease';
            setTimeout(() => { content.style.transform = 'scale(1)'; }, 10);
            const title = document.createElement('h3');
            title.style.color = '#ffcc00';
            title.style.marginBottom = '15px';
            title.textContent = `Редактировать матч ${matchId}`;
            const form = document.createElement('div');
            form.style.display = 'flex';
            form.style.flexDirection = 'column';
            form.style.gap = '10px';
            const team1Row = document.createElement('div');
            team1Row.style.display = 'flex';
            team1Row.style.alignItems = 'center';
            team1Row.style.gap = '10px';
            team1Row.innerHTML = `<span style="flex:1; overflow:hidden; text-overflow:ellipsis;">${t1}</span>`;
            const score1Input = document.createElement('input');
            score1Input.type = 'number';
            score1Input.min = '0';
            score1Input.value = match.score1 !== null ? match.score1 : '';
            score1Input.style.width = '60px';
            score1Input.style.background = 'rgba(30, 30, 50, 0.8)';
            score1Input.style.border = '1px solid rgba(255, 204, 0, 0.4)';
            score1Input.style.borderRadius = '4px';
            score1Input.style.color = 'white';
            score1Input.style.padding = '4px';
            team1Row.appendChild(score1Input);
            const team2Row = document.createElement('div');
            team2Row.style.display = 'flex';
            team2Row.style.alignItems = 'center';
            team2Row.style.gap = '10px';
            team2Row.innerHTML = `<span style="flex:1; overflow:hidden; text-overflow:ellipsis;">${t2}</span>`;
            const score2Input = document.createElement('input');
            score2Input.type = 'number';
            score2Input.min = '0';
            score2Input.value = match.score2 !== null ? match.score2 : '';
            score2Input.style.width = '60px';
            score2Input.style.background = 'rgba(30, 30, 50, 0.8)';
            score2Input.style.border = '1px solid rgba(255, 204, 0, 0.4)';
            score2Input.style.borderRadius = '4px';
            score2Input.style.color = 'white';
            score2Input.style.padding = '4px';
            team2Row.appendChild(score2Input);
            const mapSelect = document.createElement('select');
            mapSelect.style.width = '100%';
            mapSelect.style.background = 'rgba(30, 30, 50, 0.8)';
            mapSelect.style.border = '1px solid rgba(255, 204, 0, 0.4)';
            mapSelect.style.borderRadius = '4px';
            mapSelect.style.color = 'white';
            mapSelect.style.padding = '6px';
            mapSelect.innerHTML = '<option value="">—</option><option value="de_dust2">de_dust2</option><option value="de_inferno">de_inferno</option><option value="de_nuke">de_nuke</option><option value="de_tuscan">de_tuscan</option><option value="de_train">de_train</option>';
            if (match.map) mapSelect.value = match.map;
            const saveBtn = document.createElement('button');
            saveBtn.style.background = 'rgba(255, 204, 0, 0.2)';
            saveBtn.style.border = '1px solid rgba(255, 204, 0, 0.4)';
            saveBtn.style.borderRadius = '6px';
            saveBtn.style.color = '#ffcc00';
            saveBtn.style.padding = '8px 16px';
            saveBtn.style.cursor = 'pointer';
            saveBtn.style.marginTop = '10px';
            saveBtn.style.transition = 'background 0.2s';
            saveBtn.textContent = 'Сохранить';
            saveBtn.onmouseenter = () => { saveBtn.style.background = 'rgba(255, 204, 0, 0.3)'; };
            saveBtn.onmouseleave = () => { saveBtn.style.background = 'rgba(255, 204, 0, 0.2)'; };
            saveBtn.onclick = () => {
                const s1Raw = score1Input.value.trim();
                const s2Raw = score2Input.value.trim();
                const s1 = s1Raw === '' ? null : Number(s1Raw);
                const s2 = s2Raw === '' ? null : Number(s2Raw);
                const map = mapSelect.value || null;
                let winner = null;
                let loser = null;
                let completed = false;
                if (
                    s1 !== null &&
                    s2 !== null &&
                    map !== null &&
                    isFinite(s1) &&
                    isFinite(s2) &&
                    s1 >= 0 &&
                    s2 >= 0
                ) {
                    completed = true;
                    if (s1 > s2) {
                        winner = match.team1;
                        loser = match.team2;
                    } else if (s2 > s1) {
                        winner = match.team2;
                        loser = match.team1;
                    }
                }
                playoffData.matches[matchId] = {
                    team1: match.team1,
                    team2: match.team2,
                    map,
                    score1: s1,
                    score2: s2,
                    completed,
                    winner: winner,
                    loser: loser,
                    sourceBracket: getBracketSource(matchId, playoffData.format || 'moscow-mix')
                };
                playoffRef.set(playoffData);
                content.style.transform = 'scale(0.95)';
                modal.style.opacity = '0';
                setTimeout(() => {
                    modal.remove();
                    renderBracket(playoffData, standings);
                }, 300);
            };
            const closeBtn = document.createElement('button');
            closeBtn.style.background = 'rgba(255, 204, 0, 0.1)';
            closeBtn.style.border = '1px solid rgba(255, 204, 0, 0.4)';
            closeBtn.style.borderRadius = '6px';
            closeBtn.style.color = '#ffcc00';
            closeBtn.style.padding = '8px 16px';
            closeBtn.style.cursor = 'pointer';
            closeBtn.style.marginTop = '10px';
            closeBtn.style.transition = 'background 0.2s';
            closeBtn.textContent = 'Закрыть';
            closeBtn.onmouseenter = () => { closeBtn.style.background = 'rgba(255, 204, 0, 0.2)'; };
            closeBtn.onmouseleave = () => { closeBtn.style.background = 'rgba(255, 204, 0, 0.1)'; };
            closeBtn.onclick = () => {
                content.style.transform = 'scale(0.95)';
                modal.style.opacity = '0';
                setTimeout(() => { modal.remove(); }, 300);
            };
            form.appendChild(team1Row);
            form.appendChild(team2Row);
            form.appendChild(mapSelect);
            form.appendChild(saveBtn);
            form.appendChild(closeBtn);
            content.appendChild(title);
            content.appendChild(form);
            modal.appendChild(content);
            document.body.appendChild(modal);
        }

        async function archiveCurrentTournament() {
            if (!isAdmin) return;
            if (!confirm("Архивировать текущие результаты турнира?\nЭто действие нельзя отменить.")) return;
            try {
                const draftSnapshot = await draftRef.once('value');
                const draftData = draftSnapshot.val();
                if (!draftData || !draftData.draftComplete) {
                    alert("Драфт не завершён. Архивация невозможна.");
                    return;
                }
                const playoffSnapshot = await playoffRef.once('value');
                const playoffData = playoffSnapshot.val() || { matches: {}, format: 'moscow-mix' };
                const configSnapshot = await configRef.once('value');
                const config = configSnapshot.val() || {};
                const TEAM_NAMES = config.teams || {};
                const teamsMap = {};
                draftData.captainsList.forEach((captain, idx) => {
                    const teamName = TEAM_NAMES[captain] || captain;
                    const normalized = normalizeTeamName(teamName);
                    const players = draftData.teams[idx] || [];
                    teamsMap[normalized] = {
                        captain: captain,
                        players: [captain, ...players]
                    };
                });

                const pos = {
                    'A1': getTeamName(standings?.A?.[0]),
                    'A2': getTeamName(standings?.A?.[1]),
                    'A3': getTeamName(standings?.A?.[2]),
                    'A4': getTeamName(standings?.A?.[3]),
                    'B1': getTeamName(standings?.B?.[0]),
                    'B2': getTeamName(standings?.B?.[1]),
                    'B3': getTeamName(standings?.B?.[2]),
                    'B4': getTeamName(standings?.B?.[3])
                };
                const finalStandings = calculateFinalStandings(
                    playoffData,
                    TEAM_NAMES,
                    draftData.captainsList,
                    standings
                ).map(normalizeTeamName);

                if (finalStandings.every(t => t === '—')) {
                    alert("❌ Не удалось определить места. Убедитесь, что все матчи завершены.");
                    return;
                }
                const timestamp = new Date().toISOString();
                const dateStr = new Date().toISOString().split('T')[0];
                const archiveEntry = {
                    name: `Moscow M1x — ${dateStr}`,
                    format: playoffData.format || 'moscow-mix',
                    createdAt: timestamp,
                    champion: finalStandings[0] || null,
                    standings: finalStandings,
                    teams: teamsMap
                };
                await tournamentsRef.child(Date.now().toString()).set(archiveEntry);
                alert("✅ Турнир успешно архивирован!");
            } catch (err) {
                console.error("Ошибка архивации:", err);
                alert("❌ Ошибка при архивации турнира. Проверьте консоль.");
            }
        }

        function updateArchiveButtonVisibility() {
            const btn = document.getElementById('archiveBtn');
            if (!btn) return;
            if (!isAdmin || !isAuthenticated || !playoffDataGlobal || !standings) {
                btn.style.display = 'none';
                return;
            }
            const format = playoffDataGlobal.format || 'moscow-mix';
            const matches = playoffDataGlobal.matches || {};
            const pos = {
                'A1': getTeamName(standings.A[0]),
                'A2': getTeamName(standings.A[1]),
                'A3': getTeamName(standings.A[2]),
                'A4': getTeamName(standings.A[3]),
                'B1': getTeamName(standings.B[0]),
                'B2': getTeamName(standings.B[1]),
                'B3': getTeamName(standings.B[2]),
                'B4': getTeamName(standings.B[3])
            };
            let hasChampion = false;
            if (format === 'moscow-mix') {
                if (matches['M11']?.completed) hasChampion = true;
                else if (matches['M10']?.completed) {
                    const upperWinner = resolveTeamRecursive('M8', matches, pos);
                    const gfWinner = resolveTeamRecursive(matches['M10'].winner, matches, pos);
                    if (gfWinner === upperWinner) hasChampion = true;
                }
            } else if (format === 'double-elim') {
                if (matches['GF2']?.completed) hasChampion = true;
                else if (matches['GF']?.completed) {
                    const upperWinner = resolveTeamRecursive('UB3', matches, pos);
                    const gfWinner = resolveTeamRecursive(matches['GF'].winner, matches, pos);
                    if (gfWinner === upperWinner) hasChampion = true;
                }
            } else if (format === 'single-elim') {
                if (matches['FINAL']?.completed) hasChampion = true;
            }
            btn.style.display = hasChampion ? 'flex' : 'none';
        }

        async function loadConfigForPlayoff() {
            try {
                const snapshot = await configRef.once('value');
                const config = snapshot.val();
                if (config) {
                    if (Array.isArray(config.captains)) CAPTAINS = [...config.captains];
                    if (typeof config.teams === 'object') TEAM_NAMES = { ...config.teams };
                }
            } catch (e) {
                console.warn("Could not load config for playoff");
            }
        }

        function getTeamName(captain) {
            return TEAM_NAMES[captain] || captain;
        }

        function loadStandingsFromSnapshot(snapshot) {
            const data = snapshot.val();
            if (!data || !data.isGroupStageActive) return null;
            const standings = {};
            ['A', 'B'].forEach(group => {
                const teams = data.groups[group] || [];
                const matches = data.matches || {};
                const stats = {};
                teams.forEach(t => {
                    stats[t] = { team: t, wins: 0, points: 0, played: 0, roundsWon: 0, roundsLost: 0 };
                });
                Object.values(matches).forEach(m => {
                    if (m.group !== group || !m.completed) return;
                    const { team1, team2, score1, score2 } = m;
                    stats[team1].played++; stats[team2].played++;
                    stats[team1].roundsWon += score1; stats[team1].roundsLost += score2;
                    stats[team2].roundsWon += score2; stats[team2].roundsLost += score1;
                    if (score1 > score2) { stats[team1].wins++; stats[team1].points += 3; }
                    else if (score2 > score1) { stats[team2].wins++; stats[team2].points += 3; }
                    else { stats[team1].points++; stats[team2].points++; }
                });
                Object.values(stats).forEach(s => s.roundDiff = s.roundsWon - s.roundsLost);
                standings[group] = Object.values(stats).sort((a, b) => {
                    if (b.points !== a.points) return b.points - a.points;
                    if (b.wins !== a.wins) return b.wins - a.wins;
                    return b.roundDiff - a.roundDiff;
                }).map(s => s.team);
            });
            return standings;
        }

        function calculateFinalStandings(playoffData, TEAM_NAMES, CAPTAINS, groupStandings) {
            const matches = playoffData.matches || {};
            const format = playoffData.format || 'moscow-mix';
            const standings = [];
            if (format === 'moscow-mix') {
                if (matches['M11']?.completed) {
                    standings[0] = matches['M11'].winner;
                } else if (matches['M10']?.completed) {
                    standings[0] = matches['M10'].winner;
                }
                if (matches['M11']?.completed) {
                    standings[1] = matches['M11'].loser;
                } else if (matches['M10']?.completed) {
                    standings[1] = matches['M10'].loser;
                }
                if (matches['M9']?.completed) standings[2] = matches['M9'].loser;
                if (matches['M7']?.completed) standings[3] = matches['M7'].loser;
                if (matches['M5']?.completed) standings[4] = matches['M5'].loser;
                if (matches['M6']?.completed) standings[5] = matches['M6'].loser;
                if (matches['M3']?.completed) standings[6] = matches['M3'].loser;
                if (matches['M4']?.completed) standings[7] = matches['M4'].loser;
            } else if (format === 'single-elim') {
                if (matches['FINAL']?.completed) standings[0] = matches['FINAL'].winner;
                const semifinalLosers = [matches['SF1']?.loser, matches['SF2']?.loser].filter(Boolean);
                const quarterfinalLosers = [
                    matches['QF1']?.loser,
                    matches['QF2']?.loser,
                    matches['QF3']?.loser,
                    matches['QF4']?.loser
                ].filter(Boolean);
                standings[1] = matches['FINAL']?.loser || '—';
                semifinalLosers.forEach((t, i) => standings[2 + i] = t);
                quarterfinalLosers.forEach((t, i) => standings[4 + i] = t);
            } else if (format === 'double-elim') {
                if (matches['GF2']?.completed) {
                    standings[0] = matches['GF2'].winner;
                    standings[1] = matches['GF2'].loser;
                } else if (matches['GF']?.completed) {
                    standings[0] = matches['GF'].winner;
                    standings[1] = matches['GF'].loser;
                }
                if (matches['LB5']?.completed) standings[2] = matches['LB5'].loser;
            }
            const pos = {
                'A1': groupStandings?.A?.[0] || '—',
                'A2': groupStandings?.A?.[1] || '—',
                'A3': groupStandings?.A?.[2] || '—',
                'A4': groupStandings?.A?.[3] || '—',
                'B1': groupStandings?.B?.[0] || '—',
                'B2': groupStandings?.B?.[1] || '—',
                'B3': groupStandings?.B?.[2] || '—',
                'B4': groupStandings?.B?.[3] || '—'
            };
            function resolve(id) {
                if (!id || id === '—') return '—';
                if (TEAM_NAMES[id]) return TEAM_NAMES[id];
                if (CAPTAINS.includes(id)) return TEAM_NAMES[id] || id;
                if (id.length === 2 && ['A','B'].includes(id[0]) && !isNaN(id[1])) {
                    const captain = pos[id];
                    return TEAM_NAMES[captain] || captain || '—';
                }
                if (id.endsWith('_L')) {
                    const matchId = id.slice(0, -2);
                    const match = matches[matchId];
                    if (match && match.completed && match.loser) {
                        return resolve(match.loser);
                    }
                    return '—';
                }
                if (id.startsWith('M') || id.startsWith('UB') || id.startsWith('LB') || id.startsWith('QF') || id.startsWith('SF') || id.startsWith('GF')) {
                    const match = matches[id];
                    if (match && match.completed) {
                        return resolve(match.winner || match.loser || '—');
                    }
                }
                return id;
            }
            return standings.map(id => resolve(id)).filter(Boolean);
        }

        function setupFormatSelector() {
            const container = document.getElementById('formatSelectorContainer');
            const select = document.getElementById('bracketFormatSelect');
            if (!isAdmin || !isAuthenticated) {
                container.style.display = 'none';
                return;
            }
            container.style.display = 'block';
            select.addEventListener('change', async (e) => {
                const newFormat = e.target.value;
                if (newFormat === CURRENT_FORMAT) return;
                if (!confirm("⚠️ Изменение формата сбросит текущую сетку плей-офф!\nПродолжить?")) {
                    select.value = CURRENT_FORMAT;
                    return;
                }
                try {
                    await initializePlayoffBracket(newFormat);
                    CURRENT_FORMAT = newFormat;
                } catch (err) {
                    console.error("Ошибка инициализации:", err);
                    alert("Не удалось изменить формат.");
                    select.value = CURRENT_FORMAT;
                }
            });
        }

        function startRealtimePlayoff() {
            groupStageRef.on('value', (groupSnapshot) => {
                standings = loadStandingsFromSnapshot(groupSnapshot);
                if (!standings) {
                    bracketContent.innerHTML = '<div class="firebase-error">Group stage not completed yet.</div>';
                    return;
                }
                playoffRef.on('value', (playoffSnapshot) => {
                    let playoffData = playoffSnapshot.val() || { isPlayoffActive: false, matches: {} };
                    if (!playoffData.isPlayoffActive) {
                        initializePlayoffBracket('moscow-mix');
                        return;
                    }
                    renderBracket(playoffData, standings);
                    setupFormatSelector();
                });
            });
        }

        const authHeaderLink = document.getElementById('authHeaderLink');
        function updateAuthButtons() {
            authHeaderLink.textContent = isAuthenticated ? 'SIGN OUT' : 'SIGN IN';
        }

        function showLoginModal() {
            if (document.getElementById('authModal')) return;
            const overlay = document.createElement('div');
            overlay.className = 'modal-overlay';
            overlay.id = 'authModal';
            overlay.innerHTML = `
                <div class="modal-content">
                    <h3>🔐 Login</h3>
                    <input type="email" class="modal-input" id="emailInput" placeholder="Email" autocomplete="email">
                    <input type="password" class="modal-input" id="passwordInput" placeholder="Password" autocomplete="current-password">
                    <div class="modal-error" id="authError"></div>
                    <button class="modal-btn" id="submitLogin">Login</button>
                    <div class="modal-footer">
                        Contact admin for access.
                    </div>
                </div>
            `;
            document.body.appendChild(overlay);
            const submitBtn = overlay.querySelector('#submitLogin');
            const emailInput = overlay.querySelector('#emailInput');
            const passwordInput = overlay.querySelector('#passwordInput');
            const errorEl = overlay.querySelector('#authError');
            submitBtn.onclick = () => {
                const email = emailInput.value.trim();
                const password = passwordInput.value;
                if (!email || !password) {
                    errorEl.textContent = "Please fill in all fields.";
                    return;
                }
                auth.signInWithEmailAndPassword(email, password)
                    .then(() => {
                        isAuthenticated = true;
                        document.body.removeChild(overlay);
                        updateAuthButtons();
                        checkAdminStatus(auth.currentUser).then(isAdminResult => {
                            isAdmin = isAdminResult;
                            renderBracket(playoffDataGlobal, standings);
                            setupFormatSelector();
                            updateArchiveButtonVisibility();
                        });
                    })
                    .catch((error) => {
                        console.error("Auth error:", error);
                        errorEl.textContent = "Invalid email or password.";
                    });
            };
            overlay.onclick = (e) => {
                if (e.target === overlay) document.body.removeChild(overlay);
            };
        }

        authHeaderLink.onclick = () => {
            if (isAuthenticated) {
                auth.signOut().then(() => {
                    isAuthenticated = false;
                    isAdmin = false;
                    updateAuthButtons();
                    updateArchiveButtonVisibility();
                    setupFormatSelector();
                }).catch(alert);
            } else {
                showLoginModal();
            }
        };

        async function checkAdminStatus(user) {
            if (!user || !user.email) return false;
            try {
                const emailKey = user.email.replace('.', ',');
                const snapshot = await database.ref('moscowM1X/admins').child(emailKey).once('value');
                return snapshot.exists();
            } catch (error) {
                return false;
            }
        }

        auth.onAuthStateChanged((user) => {
            isAuthenticated = !!user;
            if (user) {
                checkAdminStatus(user).then(isAdminResult => {
                    isAdmin = isAdminResult;
                    updateAuthButtons();
                    if (playoffDataGlobal) {
                        renderBracket(playoffDataGlobal, standings);
                        setupFormatSelector();
                        updateArchiveButtonVisibility();
                    }
                });
            } else {
                isAdmin = false;
                updateAuthButtons();
                updateArchiveButtonVisibility();
                setupFormatSelector();
            }
        });

        document.getElementById('archiveBtn').onclick = archiveCurrentTournament;
        updateAuthButtons();
        loadConfigForPlayoff();
        startRealtimePlayoff();
    </script>
</body>
</html>